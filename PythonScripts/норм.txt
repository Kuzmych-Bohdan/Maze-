import asyncio
import websockets
import numpy as np
import json
from sklearn.linear_model import LinearRegression, Ridge
from sklearn.preprocessing import PolynomialFeatures
from sklearn.pipeline import make_pipeline
from sklearn.svm import SVR
from sklearn.ensemble import RandomForestRegressor

class PredictionServer:
    def __init__(self):
        self.data_history = {
            'clear_x': [],
            'clear_y': [],
            'wall_x': [],
            'wall_y': []
        }
        self.true_collisions = []  # –ó—ñ—Ç–∫–Ω–µ–Ω–Ω—è 0 –∞–±–æ 1
        self.models = {
            'linear': LinearRegression(),
            'polynomial': make_pipeline(
                PolynomialFeatures(degree=2),
                LinearRegression()
            ),
            'ridge': Ridge(alpha=1.0),
            'svr': SVR(kernel='rbf', C=100, gamma=0.1, epsilon=.1),
            'random_forest': RandomForestRegressor(n_estimators=100)
        }
        self.min_data_points = 5
        self.max_data_points = 50

    async def handle_client(self, websocket, path):
        print("‚úÖ –ö–ª—ñ—î–Ω—Ç –ø—ñ–¥–∫–ª—é—á–µ–Ω–∏–π")
        try:
            async for message in websocket:
                try:
                    print("\n--- –û—Ç—Ä–∏–º–∞–Ω–æ –Ω–æ–≤–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è ---")
                    data = self._parse_message(message)
                    if not data:
                        await websocket.send(json.dumps({
                            "error": "–û—Ç—Ä–∏–º–∞–Ω–æ –ø–æ—Ä–æ–∂–Ω—ñ –¥–∞–Ω—ñ",
                            "status": "error"
                        }))
                        continue

                    self._update_data(data)

                    if len(self.data_history['clear_x']) >= self.min_data_points:
                        response = self._generate_predictions()
                    else:
                        response = {
                            "status": "waiting",
                            "message": f"–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –¥–∞–Ω–∏—Ö (–ø–æ—Ç—Ä—ñ–±–Ω–æ {self.min_data_points})",
                            "current_data": len(self.data_history['clear_x'])
                        }

                    await websocket.send(json.dumps(response))

                except json.JSONDecodeError:
                    await websocket.send(json.dumps({
                        "error": "–ù–µ–≤—ñ—Ä–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç JSON",
                        "status": "error"
                    }))
                except ValueError as e:
                    await websocket.send(json.dumps({
                        "error": str(e),
                        "status": "error"
                    }))
                except Exception as e:
                    await websocket.send(json.dumps({
                        "error": "–í–Ω—É—Ç—Ä—ñ—à–Ω—è –ø–æ–º–∏–ª–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞",
                        "status": "error"
                    }))

        except websockets.exceptions.ConnectionClosed:
            print("üîå –ö–ª—ñ—î–Ω—Ç –≤—ñ–¥–∫–ª—é—á–∏–≤—Å—è")

    def _parse_message(self, message):
        try:
            data = json.loads(message)
            if not data or not data.get('clearSector') or not data.get('wallSector'):
                return None

            clear_x = data['clearSector'].get('positionClearSectorX', []) or \
                      data['clearSector'].get('positionclearSectorX', [])
            clear_y = data['clearSector'].get('positionClearSectorY', []) or \
                      data['clearSector'].get('positionclearSectorY', [])
            wall_x = data['wallSector'].get('positionWallSectorX', []) or \
                     data['wallSector'].get('positionwallSectorX', [])
            wall_y = data['wallSector'].get('positionWallSectorY', []) or \
                     data['wallSector'].get('positionwallSectorY', [])

            collisions = data.get('collisions', [])

            if not all(isinstance(lst, list) for lst in [clear_x, clear_y, wall_x, wall_y]):
                raise ValueError("–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –º–∞—é—Ç—å –±—É—Ç–∏ —Å–ø–∏—Å–∫–∞–º–∏")

            return {
                'clear_x': [float(x) for x in clear_x],
                'clear_y': [float(y) for y in clear_y],
                'wall_x': [float(x) for x in wall_x],
                'wall_y': [float(y) for y in wall_y],
                'collisions': collisions
            }

        except Exception as e:
            raise ValueError(f"–ü–æ–º–∏–ª–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥—É –¥–∞–Ω–∏—Ö: {str(e)}")

    def _update_data(self, new_data):
        for key in self.data_history:
            self.data_history[key].extend(new_data[key])
            self.data_history[key] = self.data_history[key][-self.max_data_points:]

        if 'collisions' in new_data and new_data['collisions']:
            for collision in new_data['collisions']:
                wall_status = collision.get('wall')
                if wall_status in [0, 1]:
                    self.true_collisions.append(int(wall_status))
                    self.true_collisions = self.true_collisions[-self.max_data_points:]

    def _generate_predictions(self):
        min_len = min(len(self.data_history[key]) for key in self.data_history)
        print(f"[INFO] –ö—ñ–ª—å–∫—ñ—Å—Ç—å –¥–∞–Ω–∏—Ö: {min_len} —Ç–æ—á–æ–∫")
        
        if min_len < self.min_data_points:
            print("[WARN] –ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –¥–∞–Ω–∏—Ö –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑—É")
            return {"status": "waiting", "message": "–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –¥–∞–Ω–∏—Ö"}

        X = np.column_stack((
            self.data_history['clear_x'][:min_len],
            self.data_history['wall_x'][:min_len],
            self.data_history['wall_y'][:min_len]
        ))
        y = np.array(self.data_history['clear_y'][:min_len])

        results = {"status": "success", "models": {}}
        predictions_by_model = {}

        for name, model in self.models.items():
            try:
                model.fit(X, y)
                x_pred = self.data_history['clear_x'][-5:]
                X_pred = np.column_stack((
                    x_pred,
                    self.data_history['wall_x'][-5:],
                    self.data_history['wall_y'][-5:]
                ))

                predictions = model.predict(X_pred).tolist()
                predictions_by_model[name] = predictions

                print(f"[{name.upper()}] –ü—Ä–æ–≥–Ω–æ–∑–æ–≤–∞–Ω—ñ Y: {np.round(predictions, 3).tolist()}")

                results["models"][f"{name}_X"] = x_pred
                results["models"][f"{name}_Y"] = predictions

            except Exception as e:
                print(f"[ERROR] –ú–æ–¥–µ–ª—å {name} –∑–ª–∞–º–∞–ª–∞—Å—å: {e}")
                results["models"][name] = {"error": str(e)}

        # Accuracy –ø–æ –∫–æ–ª—ñ–∑—ñ—è–º (—è–∫—â–æ —î)
        if len(self.true_collisions) >= 5:
            y_true = np.array(self.true_collisions[-5:])
            print(f"[INFO] –Ü—Å—Ç–∏–Ω–Ω—ñ –∫–æ–ª—ñ–∑—ñ—ó: {y_true.tolist()}")

            for name, preds in predictions_by_model.items():
                try:
                    y_pred_binary = [1 if p > 0.5 else 0 for p in preds]
                    accuracy = (np.array(y_pred_binary) == y_true).mean()
                    print(f"[{name.upper()}] –¢–æ—á–Ω—ñ—Å—Ç—å –ø—Ä–æ–≥–Ω–æ–∑—É –∫–æ–ª—ñ–∑—ñ–π: {round(accuracy * 100, 2)}%")

                    if 'prediction_quality' not in results:
                        results["prediction_quality"] = {}
                    results["prediction_quality"][name] = {
                        "accuracy": round(accuracy, 3),
                        "predicted": y_pred_binary,
                        "true": y_true.tolist()
                    }
                except Exception as e:
                    print(f"[ERROR] –û–±—á–∏—Å–ª–µ–Ω–Ω—è accuracy –¥–ª—è {name}: {e}")

        return results


async def main():
    server = PredictionServer()
    async with websockets.serve(
        server.handle_client,
        "localhost",
        6000,
        ping_interval=20,
        ping_timeout=30
    ):
        print("üöÄ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω–æ –Ω–∞ ws://localhost:6000")
        await asyncio.Future()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüõë –°–µ—Ä–≤–µ—Ä –∑—É–ø–∏–Ω–µ–Ω–æ")
